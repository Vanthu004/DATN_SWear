import { useEffect, useState } from "react";
import { Alert } from "react-native";
import { useAuth } from "../context/AuthContext";
import {
  addCartItem,
  clearCartItems,
  createCart,
  deleteCartItem,
  getCartByUser,
  getCartItemsByCart,
  updateCartItemQuantity
} from "../utils/api";

export const useCart = () => {
  const [cartItems, setCartItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [cartId, setCartId] = useState(null);
  const [cartStatus, setCartStatus] = useState("active");

  const { userInfo } = useAuth();
  const USER_ID = userInfo?._id || userInfo?.id;

  // L·∫•y d·ªØ li·ªáu gi·ªè h√†ng
  const fetchCartData = async () => {
    if (!USER_ID) return;

    try {
      setLoading(true);
      console.log("üß™ G·ªçi API cart c·ªßa user:", USER_ID);

      let cart;
      try {
        const response = await getCartByUser(USER_ID);
        cart = response.data; // Access the actual cart object from the 'data' field
        console.log("Cart:", cart);
        setCartId(cart._id);
        setCartStatus(cart.status || "active");
      } catch (err) {
        if (err.response?.status === 404) {
          console.log("‚ùå User ch∆∞a c√≥ cart, s·∫Ω t·∫°o m·ªõi khi c·∫ßn");
          setCartId(null);
          setCartStatus("active");
          return;
        }
        throw err;
      }

      if (!cart) {
        console.log("‚ùå Kh√¥ng t√¨m th·∫•y cart cho user");
        setCartId(null);
        setCartStatus("active");
        return;
      }

      const itemsResponse = await getCartItemsByCart(cart._id);
      console.log("ItemsResponse:", itemsResponse);
      
      // X·ª≠ l√Ω c√°c tr∆∞·ªùng h·ª£p kh√°c nhau c·ªßa response
      let items;
      if (itemsResponse && typeof itemsResponse === 'object') {
        if (Array.isArray(itemsResponse)) {
          items = itemsResponse; // Response tr·ª±c ti·∫øp l√† m·∫£ng
        } else if (itemsResponse.data && Array.isArray(itemsResponse.data)) {
          items = itemsResponse.data; // Response c√≥ data l√† m·∫£ng
        } else if (itemsResponse.data && itemsResponse.data.items && Array.isArray(itemsResponse.data.items)) {
          items = itemsResponse.data.items; // Response c√≥ data.items l√† m·∫£ng
        } else if (itemsResponse.data && Array.isArray(itemsResponse.data.data)) {
          items = itemsResponse.data.data; // Response c√≥ data.data l√† m·∫£ng
        } else {
          console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y items trong response, ƒë·∫∑t th√†nh m·∫£ng r·ªóng");
          console.log("Response structure:", JSON.stringify(itemsResponse, null, 2));
          items = []; // Fallback th√†nh m·∫£ng r·ªóng
        }
      } else {
        items = []; // Fallback th√†nh m·∫£ng r·ªóng
      }
      
      // console.log("CartItem:", items);
      // console.log("CartItem length:", items.length);

      // Ki·ªÉm tra items c√≥ ph·∫£i l√† m·∫£ng kh√¥ng
      if (!Array.isArray(items)) {
        console.log("‚ö†Ô∏è Items kh√¥ng ph·∫£i l√† m·∫£ng, ƒë·∫∑t th√†nh m·∫£ng r·ªóng");
        setCartItems([]);
        return;
      }

      const processedItems = items.map((item) => {
        // Ki·ªÉm tra n·∫øu item.product_id l√† object (ƒë√£ populate)
        if (item.product_id && typeof item.product_id === 'object' && item.product_id._id) {
          return {
            ...item,
            size: item.size || item.product_variant_id?.attributes?.size?.name || item.product_variant_id?.size,
            color: item.color || item.product_variant_id?.attributes?.color?.name || item.product_variant_id?.color,
            product: {
              ...item.product_id, // S·ª≠ d·ª•ng to√†n b·ªô th√¥ng tin s·∫£n ph·∫©m ƒë√£ populate
              _id: item.product_id._id,
              name: item.product_id.name || item.product_name,
              price: item.price_at_time || item.product_id.price,
              image_url: item.product_image || item.product_id.image_url,
              variants: item.product_id.variants || [],
            },
          };
        } else {
          // Fallback cho tr∆∞·ªùng h·ª£p ch∆∞a populate
          return {
            ...item,
            size: item.size,
            color: item.color,
            product: {
              _id: item.product_id,
              name: item.product_name,
              price: item.price_at_time,
              image_url: item.product_image,
              variants: [],
            },
          };
        }
      });

      setCartItems(processedItems);
    } catch (err) {
      console.error("‚ùå L·ªói fetch cart:", err);
      setCartItems([]);
      setCartId(null);
      setCartStatus("active");
    } finally {
      setLoading(false);
    }
  };

  // Th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng v·ªõi h·ªó tr·ª£ variants
  const addToCart = async (
    product,
    quantity = 1,
    productVariantId = null
  ) => {
    if (!USER_ID) {
      Alert.alert("L·ªói", "Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng");
      return false;
    }

    try {
      setLoading(true);
      console.log("üõí Th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng:", product.name);

      let cart;
      if (!cartId) {
        try {
          const response = await getCartByUser(USER_ID);
          cart = response.data;
          setCartId(cart._id);
          setCartStatus(cart.status || "active");
        } catch (err) {
          if (err.response?.status === 404) {
            console.log("üÜï T·∫°o cart m·ªõi cho user");
            const createResponse = await createCart(USER_ID);
            cart = createResponse.data;
            setCartId(cart._id);
            setCartStatus("active");
          } else {
            throw err;
          }
        }
      } else {
        cart = { _id: cartId };
      }

      const cartItemData = {
        cart_id: cart._id,
        product_id: product._id,
        quantity: quantity,
      };

      // Th√™m product_variant_id n·∫øu c√≥
      if (productVariantId) {
        cartItemData.product_variant_id = productVariantId;
      }

      const newItemResponse = await addCartItem(cartItemData);
      console.log("NewItemResponse:", newItemResponse);
      
      // X·ª≠ l√Ω response t·ª´ addCartItem
      let newItem;
      if (newItemResponse && typeof newItemResponse === 'object') {
        if (newItemResponse.data) {
          newItem = newItemResponse.data; // Response c√≥ data
        } else if (newItemResponse.data && newItemResponse.data.data) {
          newItem = newItemResponse.data.data; // Response c√≥ data.data
        } else {
          newItem = newItemResponse; // Response tr·ª±c ti·∫øp
        }
      } else {
        console.error("‚ùå Response kh√¥ng h·ª£p l·ªá t·ª´ addCartItem");
        throw new Error("Invalid response from addCartItem");
      }
      
      console.log("‚úÖ ƒê√£ th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng:", newItem);

      const processedItem = {
        ...newItem,
        product: {
          _id: product._id,
          name: product.name,
          price: product.price,
          image_url: product.image_url,
        },
      };

      setCartItems((prev) => [...prev, processedItem]);

      Alert.alert("Th√†nh c√¥ng", "ƒê√£ th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng");
      return true;
    } catch (err) {
      const status = err?.response?.status;
      const apiMsg = err?.response?.data?.msg || err?.response?.data?.message;
      if (status === 400 && apiMsg) {
        Alert.alert("H·∫øt h√†ng", apiMsg);
        return false;
      }
      Alert.alert("L·ªói", "Kh√¥ng th·ªÉ th√™m s·∫£n ph·∫©m v√†o gi·ªè h√†ng");
      return false;
    } finally {
      setLoading(false);
    }
  };

  // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng s·∫£n ph·∫©m
  const updateQuantity = async (itemId, newQuantity) => {
    if (newQuantity < 1) return;

    try {
      const updatedItemResponse = await updateCartItemQuantity(itemId, newQuantity);
      console.log("UpdatedItemResponse:", updatedItemResponse);
      
      // X·ª≠ l√Ω response t·ª´ updateCartItemQuantity
      let updatedItem;
      if (updatedItemResponse && typeof updatedItemResponse === 'object') {
        if (updatedItemResponse.data) {
          updatedItem = updatedItemResponse.data; // Response c√≥ data
        } else if (updatedItemResponse.data && updatedItemResponse.data.data) {
          updatedItem = updatedItemResponse.data.data; // Response c√≥ data.data
        } else {
          updatedItem = updatedItemResponse; // Response tr·ª±c ti·∫øp
        }
      } else {
        console.error("‚ùå Response kh√¥ng h·ª£p l·ªá t·ª´ updateCartItemQuantity");
        throw new Error("Invalid response from updateCartItemQuantity");
      }

      setCartItems((prev) => {
        const updated = [...prev];
        const index = updated.findIndex((item) => item._id === itemId);
        if (index !== -1) {
          updated[index] = { ...updated[index], quantity: newQuantity };
        }
        return updated;
      });
    } catch (err) {
      console.error("‚ùå L·ªói c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng:", err);
      Alert.alert("L·ªói", "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng");
    }
  };

  // X√≥a s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng
  const removeFromCart = async (itemId) => {
    try {
      await deleteCartItem(itemId);
      
      // C·∫≠p nh·∫≠t local
      setCartItems((prev) => prev.filter((item) => item._id !== itemId));
      
      // üëâ Load l·∫°i to√†n b·ªô cart ƒë·ªÉ ƒë·ªìng b·ªô h√≥a
      await fetchCartData();
      
    } catch (err) {
      console.error("‚ùå L·ªói xo√° s·∫£n ph·∫©m:", err);
      Alert.alert("L·ªói", "Kh√¥ng th·ªÉ xo√° s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng");
    }
  };

  // X√≥a t·∫•t c·∫£ items trong cart
  const clearCart = async () => {
    if (!cartId) return;

    try {
      await clearCartItems(cartId);
      setCartItems([]);
      Alert.alert("Th√†nh c√¥ng", "ƒê√£ x√≥a t·∫•t c·∫£ s·∫£n ph·∫©m kh·ªèi gi·ªè h√†ng");
    } catch (err) {
      console.error("‚ùå L·ªói x√≥a t·∫•t c·∫£ s·∫£n ph·∫©m:", err);
      Alert.alert("L·ªói", "Kh√¥ng th·ªÉ x√≥a t·∫•t c·∫£ s·∫£n ph·∫©m");
    }
  };

  // C·∫≠p nh·∫≠t tr·∫°ng th√°i cart
  const updateCartStatusHook = async (status, note = null) => {
    if (!cartId) return;

    try {
      await updateCartStatus(cartId, status, note);
      setCartStatus(status);
      console.log("‚úÖ ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i cart:", status);
    } catch (err) {
      console.error("‚ùå L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i cart:", err);
      Alert.alert("L·ªói", "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i gi·ªè h√†ng");
    }
  };

  const getTotal = () => {
    return cartItems.reduce(
      (sum, item) => sum + (item.price_at_time || item.product?.price || 0) * item.quantity,
      0
    );
  };

  // Ki·ªÉm tra s·∫£n ph·∫©m c√≥ trong cart kh√¥ng (bao g·ªìm variant)
  const isInCart = (productId, productVariantId = null) => {
    return cartItems.some((item) => {
      const productMatch = item.product_id === productId;
      if (productVariantId) {
        return productMatch && item.product_variant_id === productVariantId;
      }
      return productMatch;
    });
  };

  // L·∫•y item trong cart theo product v√† variant
  const getCartItem = (productId, productVariantId = null) => {
    return cartItems.find((item) => {
      const productMatch = item.product_id === productId;
      if (productVariantId) {
        return productMatch && item.product_variant_id === productVariantId;
      }
      return productMatch;
    });
  };

  useEffect(() => {
    fetchCartData();
  }, [USER_ID]);

// ... gi·ªØ nguy√™n ph·∫ßn import v√† c√°c h√†m kh√°c
const getTotalQuantity = () => {
  return cartItems.length;
};


  useEffect(() => {
    fetchCartData();
  }, [USER_ID]);

  return {
    cartItems,
    cartCount: getTotalQuantity(), // ‚úÖ S·ª≠a l·∫°i t·ª´ cartItems.length
    cartId,
    cartStatus,
    loading,
    addToCart,
    updateQuantity,
    removeFromCart,
    clearCart,
    updateCartStatus: updateCartStatusHook,
    getTotal,
    isInCart,
    getCartItem,
    refreshCart: fetchCartData,
  };
};